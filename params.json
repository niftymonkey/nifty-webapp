{
  "name": "nifty-webapp",
  "tagline": "Fairly minimalistic boilerplate for a modern webapp",
  "body": "# Web App Boilerplate\r\n  \r\n> Because we all really just wanna get right down to building an app, with zero upfront bullshit tooling setup cost.  \r\n\r\nThis boilerplate is intended to find a sweet spot between barebones for building a maintainable web application \r\nand not having the-kitchen-sink thrown in from the start.\r\n   \r\n\r\n## Usage\r\nTo use this boilerplate as a basis for a new application:\r\n\r\n1. Clone this repo\r\n2. Change the relevant bits in package.json\r\n3. Run the following: `npm i && npm start`\r\n4. Open `http://localhost:3000`\r\n    \r\nAnd that's it!  \r\n  \r\n\r\n## Motivation\r\nSo we've all been feeling the [javascript fatigue][js-fatigue] in web development.  After starting a bunch of side \r\nprojects to learn technologies, frameworks, and libraries, I found myself performing the same setup over and over again. \r\nI tried using quite a few of the many static boilerplates and yeoman generators out there ... some of which are VERY \r\nwell put together. However, I always found myself wanting slightly more of control over what got dropped in for any \r\ngiven project.  I will likely be borrowing some of my favorite concepts from some of these [other][react-slingshot] \r\n[boilerplates][rrsk] for this one.\r\n\r\n### Tenets\r\nWhat I want out of a boilerplate comes down to this:\r\n\r\n1. **Dev Speed**  \r\nThis is the main and most important tenet here.  Something small that covers fundamentals is what's going to get us \r\nwriting the code that matters ASAP. \r\n  \r\n  \r\n2. **Simplicity / Configurability**  \r\nRather than having a boilerplate that does ALL THE THINGS, I prefer something with the absolute basics of a good project\r\nso that you can choose what technologies you want when the time is right.  Even the \"basics\" I choose here are items \r\nthat I'd want to eventually make configurable (via yeoman perhaps)\r\n  \r\n  \r\n3. **Documentation**  \r\nThis means having a boilerplate that's easy to walk through, has information about what each of the dev dependencies\r\nis for, and that has meaningful comments so that the whole thing doesn't just become a big pile of magic.\r\n  \r\n  \r\n### What this boilerplate brings\r\n* **Transpiling** - [[babel]]  \r\nWe're [continually getting more][tc39-ecma] features and language improvements and as a result, one of the the first \r\nthings I want to do is have the ability to write code in the most recent version of the language ... and have that \r\ntranspiled down into browser-ready javascript for me.  Babel is what's getting me there.\r\n  \r\n  \r\n* **Small Size** - [[webpack]]  \r\nOne of my biggest pet peeves when starting a new project writing the first few lines, transpiling it down, and seeing a \r\nridiculously large bundle come out the other end.  WTF?  So, this boilerplate will always emit bundles that have the \r\n**smallest footprint possible**. \r\n\r\n  * While I'd love to start with the ability to drop it down another notch with [tree-shaking][tree-shaking], this is \r\n    only supported in the 2.x version of webpack which currently is still in beta. Also, webpack's 2.x documentation\r\n    is still lacking.  Will pull that in when it's better supported/documented.\r\n  \r\n  \r\n* **Debugging** - [[webpack]]  \r\nIf I can't make use of the debugging tools available to me right from the start, that's a deal-breaker. As a result, \r\nsourcemaps are a requirement here.  \r\n  \r\n  \r\n* **Production-Ready from the start** - [[webpack]]  \r\nHaving a singular production-ready (minified/compacted) artifact that can be easily served up no only helps with dev \r\nspeed, but it also gives you a feel for how your application code is growing as you iterate.  Webpack's bundling output\r\nis great for keeping track of this.  \r\n  \r\n  \r\n* **Testing** - [[ava]]  \r\nHaving easy access to a test framework that is _**FAST**_ is a must for me.\r\n  \r\n\r\n* **Linting** - [[eslint]]  \r\nCode consistency is hard enough, let's automate what we can.  A linter that can plug in any of the common code style \r\nguides easily is what I'm going for.\r\n  \r\n  \r\n* **NPM/Node Scripts** - [[npm][npm-scripts]/[node]]  \r\nLet's not start with any unnecessary tooling abstractions. If you're interested in a deeper dive about the why, \r\nread [this article][why-npm-scripts].\r\n  \r\n  \r\n* **Auto Reloading** - [[webpack-hmr]]  \r\nSaving, running a build, and reloading the page are so easy to automate these days, that this is just a great \r\ndev-speed bonus.  This will end up in here, probably in the [HMR][hmr] flavor.  Also, it will be opt-in via npm script\r\n  \r\n  \r\n* **Code Coverage** - [[nyc]]  \r\nThis is just something that I feel can fall into the testing trap where you dig yourself a hole and then have to spend\r\ntons of time later trying to dig yourself out.  Having this from the start seems like the way to go.\r\n\r\n### What this boilerplate DOES NOT bring\r\n* **Frameworks and Libraries**\r\nLet's not tie any of those in unnecessarily, especially since this boilerplate is \r\nintended to be used with any frameworks and libraries.  I'd say that at best, configuring in a framework or library \r\nis a job for the yeoman generator version of this boilerplate to do at project creation time.\r\n  \r\n  \r\n* **CSS Preprocessors**  \r\nThis really falls into the same boat as frameworks and libraries above.  Honestly, this should be up to you and/or \r\nyour friendly yeoman generator version of this to decide.\r\n  \r\n\r\n## Roadmap\r\nSo I'm starting small and might even \"release\" versions so I can go back to previous, more basic, stages of this\r\nboilerplate.  Here's where I plan on going with this, not necessarily in this order.\r\n\r\n✔ Simple html/javascript example files transpiled into tiny output bundles (with sourcemaps)  \r\n✔ Image file support (bundled/moved by webpack)  \r\n✔ CSS support (with sourcemaps)  \r\n✔ Linting support  \r\n✔ Editor Config support  \r\n✔ Auto Reloading support  \r\n☐ Test framework support  \r\n☐ Code Coverage support  \r\n✔ Production artifact build step  \r\n✔ [Yeoman generator][gnw]\r\n\r\n\r\n[js-fatigue]:      https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4\r\n[react-slingshot]: https://github.com/coryhouse/react-slingshot\r\n[rrsk]:            https://github.com/davezuko/react-redux-starter-kit\r\n[tc39-ecma]:       https://github.com/tc39/ecma262\r\n[tree-shaking]:    http://www.2ality.com/2015/12/webpack-tree-shaking.html\r\n[why-npm-scripts]: https://medium.freecodecamp.com/why-i-left-gulp-and-grunt-for-npm-scripts-3d6853dd22b8\r\n[hmr]:             https://webpack.github.io/docs/hot-module-replacement-with-webpack.html\r\n[babel]:           https://babeljs.io/\r\n[webpack]:         http://webpack.github.io/\r\n[webpack-hmr]:     https://webpack.github.io/docs/hot-module-replacement-with-webpack.html\r\n[ava]:             https://github.com/sindresorhus/ava\r\n[eslint]:          http://eslint.org/\r\n[npm-scripts]:     https://docs.npmjs.com/misc/scripts\r\n[node]:            https://nodejs.org/en/\r\n[nyc]:             https://github.com/bcoe/nyc\r\n[gnw]:             https://github.com/niftymonkey/generator-nifty-webapp\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}